; .\DES.SRC generated from: DES.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE DES.c BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE SRC(.\DES.SRC)

$NOMOD51

NAME	DES

P0	DATA	080H
P1	DATA	090H
P2	DATA	0A0H
P3	DATA	0B0H
T0	BIT	0B0H.4
AC	BIT	0D0H.6
T1	BIT	0B0H.5
T2	BIT	090H.0
EA	BIT	0A8H.7
IE	DATA	0A8H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
ES	BIT	0A8H.4
IP	DATA	0B8H
RI	BIT	098H.0
INT0	BIT	0B0H.2
CY	BIT	0D0H.7
TI	BIT	098H.1
INT1	BIT	0B0H.3
RCAP2H	DATA	0CBH
PS	BIT	0B8H.4
SP	DATA	081H
T2EX	BIT	090H.1
OV	BIT	0D0H.2
RCAP2L	DATA	0CAH
C_T2	BIT	0C8H.1
WR	BIT	0B0H.6
RCLK	BIT	0C8H.5
TCLK	BIT	0C8H.4
SBUF	DATA	099H
PCON	DATA	087H
SCON	DATA	098H
TMOD	DATA	089H
TCON	DATA	088H
IE0	BIT	088H.1
IE1	BIT	088H.3
B	DATA	0F0H
CP_RL2	BIT	0C8H.0
ACC	DATA	0E0H
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RB8	BIT	098H.2
TH0	DATA	08CH
EX0	BIT	0A8H.0
IT0	BIT	088H.0
TH1	DATA	08DH
TB8	BIT	098H.3
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
SM0	BIT	098H.7
TL0	DATA	08AH
SM1	BIT	098H.6
TL1	DATA	08BH
SM2	BIT	098H.5
TL2	DATA	0CCH
PT0	BIT	0B8H.1
PT1	BIT	0B8H.3
RS0	BIT	0D0H.3
PT2	BIT	0B8H.5
TR0	BIT	088H.4
RS1	BIT	0D0H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DPH	DATA	083H
DPL	DATA	082H
EXEN2	BIT	0C8H.3
REN	BIT	098H.4
T2CON	DATA	0C8H
RXD	BIT	0B0H.0
TXD	BIT	0B0H.1
F0	BIT	0D0H.5
PSW	DATA	0D0H
?PR?_?permute?DES    SEGMENT CODE 
?PR?_?shiftkey?DES   SEGMENT CODE 
?PR?_?shiftkey_inv?DES                   SEGMENT CODE 
?PR?_?splitin6bitwords?DES               SEGMENT CODE 
?PR?_?substitute?DES SEGMENT CODE 
?PR?_?des_f?DES      SEGMENT CODE 
?PR?_?encrypt?DES    SEGMENT CODE 
?PR?_?decrypt?DES    SEGMENT CODE 
?CO?DES              SEGMENT CODE 
	EXTRN	DATA (?C_IBP)
	EXTRN	CODE (?C?CLDOPTR)
	EXTRN	CODE (?C?CLDPTR)
	EXTRN	CODE (?C?CSTOPTR)
	EXTRN	CODE (?C?COPY)
	EXTRN	CODE (?C?LSTIDATA)
	EXTRN	CODE (?C?LSTKIDATA)
	EXTRN	CODE (?C?CSTPTR)
	EXTRN	CODE (?C?LLDIDATA)
	EXTRN	CODE (?C?LSHL)
	EXTRN	CODE (?C?LLDIDATA0)
	PUBLIC	shiftkeyinv_permtab
	PUBLIC	shiftkey_permtab
	PUBLIC	splitin6bitword_permtab
	PUBLIC	pc2_permtab
	PUBLIC	pc1_permtab
	PUBLIC	inv_ip_permtab
	PUBLIC	ip_permtab
	PUBLIC	p_permtab
	PUBLIC	e_permtab
	PUBLIC	sbox
	PUBLIC	_?decrypt
	PUBLIC	_?encrypt
	PUBLIC	_?des_f
	PUBLIC	_?substitute
	PUBLIC	_?splitin6bitwords
	PUBLIC	_?shiftkey_inv
	PUBLIC	_?shiftkey
	PUBLIC	_?permute

	RSEG  ?CO?DES
sbox:
	DB	0E4H
	DB	0D1H
	DB	02FH
	DB	0B8H
	DB	03AH
	DB	06CH
	DB	059H
	DB	007H
	DB	00FH
	DB	074H
	DB	0E2H
	DB	0D1H
	DB	0A6H
	DB	0CBH
	DB	095H
	DB	038H
	DB	041H
	DB	0E8H
	DB	0D6H
	DB	02BH
	DB	0FCH
	DB	097H
	DB	03AH
	DB	050H
	DB	0FCH
	DB	082H
	DB	049H
	DB	017H
	DB	05BH
	DB	03EH
	DB	0A0H
	DB	06DH
	DB	0F1H
	DB	08EH
	DB	06BH
	DB	034H
	DB	097H
	DB	02DH
	DB	0C0H
	DB	05AH
	DB	03DH
	DB	047H
	DB	0F2H
	DB	08EH
	DB	0C0H
	DB	01AH
	DB	069H
	DB	0B5H
	DB	00EH
	DB	07BH
	DB	0A4H
	DB	0D1H
	DB	058H
	DB	0C6H
	DB	093H
	DB	02FH
	DB	0D8H
	DB	0A1H
	DB	03FH
	DB	042H
	DB	0B6H
	DB	07CH
	DB	005H
	DB	0E9H
	DB	0A0H
	DB	09EH
	DB	063H
	DB	0F5H
	DB	01DH
	DB	0C7H
	DB	0B4H
	DB	028H
	DB	0D7H
	DB	009H
	DB	034H
	DB	06AH
	DB	028H
	DB	05EH
	DB	0CBH
	DB	0F1H
	DB	0D6H
	DB	049H
	DB	08FH
	DB	030H
	DB	0B1H
	DB	02CH
	DB	05AH
	DB	0E7H
	DB	01AH
	DB	0D0H
	DB	069H
	DB	087H
	DB	04FH
	DB	0E3H
	DB	0B5H
	DB	02CH
	DB	07DH
	DB	0E3H
	DB	006H
	DB	09AH
	DB	012H
	DB	085H
	DB	0BCH
	DB	04FH
	DB	0D8H
	DB	0B5H
	DB	06FH
	DB	003H
	DB	047H
	DB	02CH
	DB	01AH
	DB	0E9H
	DB	0A6H
	DB	090H
	DB	0CBH
	DB	07DH
	DB	0F1H
	DB	03EH
	DB	052H
	DB	084H
	DB	03FH
	DB	006H
	DB	0A1H
	DB	0D8H
	DB	094H
	DB	05BH
	DB	0C7H
	DB	02EH
	DB	02CH
	DB	041H
	DB	07AH
	DB	0B6H
	DB	085H
	DB	03FH
	DB	0D0H
	DB	0E9H
	DB	0EBH
	DB	02CH
	DB	047H
	DB	0D1H
	DB	050H
	DB	0FAH
	DB	039H
	DB	086H
	DB	042H
	DB	01BH
	DB	0ADH
	DB	078H
	DB	0F9H
	DB	0C5H
	DB	063H
	DB	00EH
	DB	0B8H
	DB	0C7H
	DB	01EH
	DB	02DH
	DB	06FH
	DB	009H
	DB	0A4H
	DB	053H
	DB	0C1H
	DB	0AFH
	DB	092H
	DB	068H
	DB	00DH
	DB	034H
	DB	0E7H
	DB	05BH
	DB	0AFH
	DB	042H
	DB	07CH
	DB	095H
	DB	061H
	DB	0DEH
	DB	00BH
	DB	038H
	DB	09EH
	DB	0F5H
	DB	028H
	DB	0C3H
	DB	070H
	DB	04AH
	DB	01DH
	DB	0B6H
	DB	043H
	DB	02CH
	DB	095H
	DB	0FAH
	DB	0BEH
	DB	017H
	DB	060H
	DB	08DH
	DB	04BH
	DB	02EH
	DB	0F0H
	DB	08DH
	DB	03CH
	DB	097H
	DB	05AH
	DB	061H
	DB	0D0H
	DB	0B7H
	DB	049H
	DB	01AH
	DB	0E3H
	DB	05CH
	DB	02FH
	DB	086H
	DB	014H
	DB	0BDH
	DB	0C3H
	DB	07EH
	DB	0AFH
	DB	068H
	DB	005H
	DB	092H
	DB	06BH
	DB	0D8H
	DB	014H
	DB	0A7H
	DB	095H
	DB	00FH
	DB	0E2H
	DB	03CH
	DB	0D2H
	DB	084H
	DB	06FH
	DB	0B1H
	DB	0A9H
	DB	03EH
	DB	050H
	DB	0C7H
	DB	01FH
	DB	0D8H
	DB	0A3H
	DB	074H
	DB	0C5H
	DB	06BH
	DB	00EH
	DB	092H
	DB	07BH
	DB	041H
	DB	09CH
	DB	0E2H
	DB	006H
	DB	0ADH
	DB	0F3H
	DB	058H
	DB	021H
	DB	0E7H
	DB	04AH
	DB	08DH
	DB	0FCH
	DB	090H
	DB	035H
	DB	06BH

e_permtab:
	DB	004H
	DB	006H
	DB	020H
	DB	001H
	DB	002H
	DB	003H
	DB	004H
	DB	005H
	DB	004H
	DB	005H
	DB	006H
	DB	007H
	DB	008H
	DB	009H
	DB	008H
	DB	009H
	DB	00AH
	DB	00BH
	DB	00CH
	DB	00DH
	DB	00CH
	DB	00DH
	DB	00EH
	DB	00FH
	DB	010H
	DB	011H
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	018H
	DB	019H
	DB	01AH
	DB	01BH
	DB	01CH
	DB	01DH
	DB	01CH
	DB	01DH
	DB	01EH
	DB	01FH
	DB	020H
	DB	001H

p_permtab:
	DB	004H
	DB	004H
	DB	010H
	DB	007H
	DB	014H
	DB	015H
	DB	01DH
	DB	00CH
	DB	01CH
	DB	011H
	DB	001H
	DB	00FH
	DB	017H
	DB	01AH
	DB	005H
	DB	012H
	DB	01FH
	DB	00AH
	DB	002H
	DB	008H
	DB	018H
	DB	00EH
	DB	020H
	DB	01BH
	DB	003H
	DB	009H
	DB	013H
	DB	00DH
	DB	01EH
	DB	006H
	DB	016H
	DB	00BH
	DB	004H
	DB	019H

ip_permtab:
	DB	008H
	DB	008H
	DB	03AH
	DB	032H
	DB	02AH
	DB	022H
	DB	01AH
	DB	012H
	DB	00AH
	DB	002H
	DB	03CH
	DB	034H
	DB	02CH
	DB	024H
	DB	01CH
	DB	014H
	DB	00CH
	DB	004H
	DB	03EH
	DB	036H
	DB	02EH
	DB	026H
	DB	01EH
	DB	016H
	DB	00EH
	DB	006H
	DB	040H
	DB	038H
	DB	030H
	DB	028H
	DB	020H
	DB	018H
	DB	010H
	DB	008H
	DB	039H
	DB	031H
	DB	029H
	DB	021H
	DB	019H
	DB	011H
	DB	009H
	DB	001H
	DB	03BH
	DB	033H
	DB	02BH
	DB	023H
	DB	01BH
	DB	013H
	DB	00BH
	DB	003H
	DB	03DH
	DB	035H
	DB	02DH
	DB	025H
	DB	01DH
	DB	015H
	DB	00DH
	DB	005H
	DB	03FH
	DB	037H
	DB	02FH
	DB	027H
	DB	01FH
	DB	017H
	DB	00FH
	DB	007H

inv_ip_permtab:
	DB	008H
	DB	008H
	DB	028H
	DB	008H
	DB	030H
	DB	010H
	DB	038H
	DB	018H
	DB	040H
	DB	020H
	DB	027H
	DB	007H
	DB	02FH
	DB	00FH
	DB	037H
	DB	017H
	DB	03FH
	DB	01FH
	DB	026H
	DB	006H
	DB	02EH
	DB	00EH
	DB	036H
	DB	016H
	DB	03EH
	DB	01EH
	DB	025H
	DB	005H
	DB	02DH
	DB	00DH
	DB	035H
	DB	015H
	DB	03DH
	DB	01DH
	DB	024H
	DB	004H
	DB	02CH
	DB	00CH
	DB	034H
	DB	014H
	DB	03CH
	DB	01CH
	DB	023H
	DB	003H
	DB	02BH
	DB	00BH
	DB	033H
	DB	013H
	DB	03BH
	DB	01BH
	DB	022H
	DB	002H
	DB	02AH
	DB	00AH
	DB	032H
	DB	012H
	DB	03AH
	DB	01AH
	DB	021H
	DB	001H
	DB	029H
	DB	009H
	DB	031H
	DB	011H
	DB	039H
	DB	019H

pc1_permtab:
	DB	008H
	DB	007H
	DB	039H
	DB	031H
	DB	029H
	DB	021H
	DB	019H
	DB	011H
	DB	009H
	DB	001H
	DB	03AH
	DB	032H
	DB	02AH
	DB	022H
	DB	01AH
	DB	012H
	DB	00AH
	DB	002H
	DB	03BH
	DB	033H
	DB	02BH
	DB	023H
	DB	01BH
	DB	013H
	DB	00BH
	DB	003H
	DB	03CH
	DB	034H
	DB	02CH
	DB	024H
	DB	03FH
	DB	037H
	DB	02FH
	DB	027H
	DB	01FH
	DB	017H
	DB	00FH
	DB	007H
	DB	03EH
	DB	036H
	DB	02EH
	DB	026H
	DB	01EH
	DB	016H
	DB	00EH
	DB	006H
	DB	03DH
	DB	035H
	DB	02DH
	DB	025H
	DB	01DH
	DB	015H
	DB	00DH
	DB	005H
	DB	01CH
	DB	014H
	DB	00CH
	DB	004H

pc2_permtab:
	DB	007H
	DB	006H
	DB	00EH
	DB	011H
	DB	00BH
	DB	018H
	DB	001H
	DB	005H
	DB	003H
	DB	01CH
	DB	00FH
	DB	006H
	DB	015H
	DB	00AH
	DB	017H
	DB	013H
	DB	00CH
	DB	004H
	DB	01AH
	DB	008H
	DB	010H
	DB	007H
	DB	01BH
	DB	014H
	DB	00DH
	DB	002H
	DB	029H
	DB	034H
	DB	01FH
	DB	025H
	DB	02FH
	DB	037H
	DB	01EH
	DB	028H
	DB	033H
	DB	02DH
	DB	021H
	DB	030H
	DB	02CH
	DB	031H
	DB	027H
	DB	038H
	DB	022H
	DB	035H
	DB	02EH
	DB	02AH
	DB	032H
	DB	024H
	DB	01DH
	DB	020H

splitin6bitword_permtab:
	DB	008H
	DB	008H
	DB	040H
	DB	040H
	DB	001H
	DB	006H
	DB	002H
	DB	003H
	DB	004H
	DB	005H
	DB	040H
	DB	040H
	DB	007H
	DB	00CH
	DB	008H
	DB	009H
	DB	00AH
	DB	00BH
	DB	040H
	DB	040H
	DB	00DH
	DB	012H
	DB	00EH
	DB	00FH
	DB	010H
	DB	011H
	DB	040H
	DB	040H
	DB	013H
	DB	018H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	040H
	DB	040H
	DB	019H
	DB	01EH
	DB	01AH
	DB	01BH
	DB	01CH
	DB	01DH
	DB	040H
	DB	040H
	DB	01FH
	DB	024H
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	040H
	DB	040H
	DB	025H
	DB	02AH
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	040H
	DB	040H
	DB	02BH
	DB	030H
	DB	02CH
	DB	02DH
	DB	02EH
	DB	02FH

shiftkey_permtab:
	DB	007H
	DB	007H
	DB	002H
	DB	003H
	DB	004H
	DB	005H
	DB	006H
	DB	007H
	DB	008H
	DB	009H
	DB	00AH
	DB	00BH
	DB	00CH
	DB	00DH
	DB	00EH
	DB	00FH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01AH
	DB	01BH
	DB	01CH
	DB	001H
	DB	01EH
	DB	01FH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02AH
	DB	02BH
	DB	02CH
	DB	02DH
	DB	02EH
	DB	02FH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	01DH

shiftkeyinv_permtab:
	DB	007H
	DB	007H
	DB	01CH
	DB	001H
	DB	002H
	DB	003H
	DB	004H
	DB	005H
	DB	006H
	DB	007H
	DB	008H
	DB	009H
	DB	00AH
	DB	00BH
	DB	00CH
	DB	00DH
	DB	00EH
	DB	00FH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01AH
	DB	01BH
	DB	038H
	DB	01DH
	DB	01EH
	DB	01FH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02AH
	DB	02BH
	DB	02CH
	DB	02DH
	DB	02EH
	DB	02FH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H

; /*
; *********************************************************************************************************
; *                                        DES-Algorithm-Implementation
; *                                          Data Encryption Standard
; *
; *                                           (c) Copyright 2015
; *                                           All Rights Reserved
; *
; * Original version taken from the AVR-Crypto-Lib
; * (http://www.das-labor.org/wiki/AVR-Crypto-Lib)
; * Copyright (C) 2006-2010  Daniel Otte (daniel.otte@rub.de)
; *
; * This program is free software: you can redistribute it and/or modify
; * it under the terms of the GNU General Public License as published by
; * the Free Software Foundation, either version 3 of the License, or
; * (at your option) any later version.
; *
; * This program is distributed in the hope that it will be useful,
; * but WITHOUT ANY WARRANTY; without even the implied warranty of
; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; * GNU General Public License for more details.
; *
; * You should have received a copy of the GNU General Public License
; * along with this program.  If not, see <http://www.gnu.org/licenses/>.
; *
; * File    : DES.C
; * By      : Mostafa Abd El-Fatah, 2015
; * Version : V1
; *
; *********************************************************************************************************
; */
; 
; 
; #include "DES.h"
; #include "uart.h"
; 
; /*
; **************************************************************************************************************
; *                                               VARIABLES
; **************************************************************************************************************
; */
; 
; 
; 
; // S-Box
; // Each value represents 4 bits that the 6-bit input is mapped to.
; //
; // This is in a different order than you would normally find it in an DES
; // reference, so that the sbox lookup is reduced to a single lookup on the
; // input byte.
; code const uint8_t sbox[256]  =
; {
;     /* S-box 1 */
;     0xE4, 0xD1, 0x2F, 0xB8, 0x3A, 0x6C, 0x59, 0x07,
;     0x0F, 0x74, 0xE2, 0xD1, 0xA6, 0xCB, 0x95, 0x38,
;     0x41, 0xE8, 0xD6, 0x2B, 0xFC, 0x97, 0x3A, 0x50,
;     0xFC, 0x82, 0x49, 0x17, 0x5B, 0x3E, 0xA0, 0x6D,
;     /* S-box 2 */
;     0xF1, 0x8E, 0x6B, 0x34, 0x97, 0x2D, 0xC0, 0x5A,
;     0x3D, 0x47, 0xF2, 0x8E, 0xC0, 0x1A, 0x69, 0xB5,
;     0x0E, 0x7B, 0xA4, 0xD1, 0x58, 0xC6, 0x93, 0x2F,
;     0xD8, 0xA1, 0x3F, 0x42, 0xB6, 0x7C, 0x05, 0xE9,
;     /* S-box 3 */
;     0xA0, 0x9E, 0x63, 0xF5, 0x1D, 0xC7, 0xB4, 0x28,
;     0xD7, 0x09, 0x34, 0x6A, 0x28, 0x5E, 0xCB, 0xF1,
;     0xD6, 0x49, 0x8F, 0x30, 0xB1, 0x2C, 0x5A, 0xE7,
;     0x1A, 0xD0, 0x69, 0x87, 0x4F, 0xE3, 0xB5, 0x2C,
;     /* S-box 4 */
;     0x7D, 0xE3, 0x06, 0x9A, 0x12, 0x85, 0xBC, 0x4F,
;     0xD8, 0xB5, 0x6F, 0x03, 0x47, 0x2C, 0x1A, 0xE9,
;     0xA6, 0x90, 0xCB, 0x7D, 0xF1, 0x3E, 0x52, 0x84,
;     0x3F, 0x06, 0xA1, 0xD8, 0x94, 0x5B, 0xC7, 0x2E,
;     /* S-box 5 */
;     0x2C, 0x41, 0x7A, 0xB6, 0x85, 0x3F, 0xD0, 0xE9,
;     0xEB, 0x2C, 0x47, 0xD1, 0x50, 0xFA, 0x39, 0x86,
;     0x42, 0x1B, 0xAD, 0x78, 0xF9, 0xC5, 0x63, 0x0E,
;     0xB8, 0xC7, 0x1E, 0x2D, 0x6F, 0x09, 0xA4, 0x53,
;     /* S-box 6 */
;     0xC1, 0xAF, 0x92, 0x68, 0x0D, 0x34, 0xE7, 0x5B,
;     0xAF, 0x42, 0x7C, 0x95, 0x61, 0xDE, 0x0B, 0x38,
;     0x9E, 0xF5, 0x28, 0xC3, 0x70, 0x4A, 0x1D, 0xB6,
;     0x43, 0x2C, 0x95, 0xFA, 0xBE, 0x17, 0x60, 0x8D,
;     /* S-box 7 */
;     0x4B, 0x2E, 0xF0, 0x8D, 0x3C, 0x97, 0x5A, 0x61,
;     0xD0, 0xB7, 0x49, 0x1A, 0xE3, 0x5C, 0x2F, 0x86,
;     0x14, 0xBD, 0xC3, 0x7E, 0xAF, 0x68, 0x05, 0x92,
;     0x6B, 0xD8, 0x14, 0xA7, 0x95, 0x0F, 0xE2, 0x3C,
;     /* S-box 8 */
;     0xD2, 0x84, 0x6F, 0xB1, 0xA9, 0x3E, 0x50, 0xC7,
;     0x1F, 0xD8, 0xA3, 0x74, 0xC5, 0x6B, 0x0E, 0x92,
;     0x7B, 0x41, 0x9C, 0xE2, 0x06, 0xAD, 0xF3, 0x58,
;     0x21, 0xE7, 0x4A, 0x8D, 0xFC, 0x90, 0x35, 0x6B
; };
; 
; // Applied to the half-block at the beginning of the Fiestel function.
; //expansion_permutation
; code const uint8_t e_permtab[]  =
; {
;     4,  6,                                         /* 4 bytes in 6 bytes out*/
;     32,  1,  2,  3,  4,  5,
;     4,  5,  6,  7,  8,  9,
;     8,  9, 10, 11, 12, 13,
;     12, 13, 14, 15, 16, 17,
;     16, 17, 18, 19, 20, 21,
;     20, 21, 22, 23, 24, 25,
;     24, 25, 26, 27, 28, 29,
;     28, 29, 30, 31, 32,  1
; };
; 
; // Applied at the end of the Feistel function.
; code const uint8_t p_permtab[]  =
; {
;     4,  4,                                         /* 32 bit -> 32 bit */
;     16,  7, 20, 21,
;     29, 12, 28, 17,
;     1, 15, 23, 26,
;     5, 18, 31, 10,
;     2,  8, 24, 14,
;     32, 27,  3,  9,
;     19, 13, 30,  6,
;     22, 11,  4, 25
; };
; 
; // Applied once at the beginning of the algorithm.
; code const uint8_t ip_permtab[]  =
; {
;     8,  8,                                         /* 64 bit -> 64 bit */
;     //initial_permutation_left
;     58, 50, 42, 34, 26, 18, 10, 2,
;     60, 52, 44, 36, 28, 20, 12, 4,
;     62, 54, 46, 38, 30, 22, 14, 6,
;     64, 56, 48, 40, 32, 24, 16, 8,
;     //initial_permutation_right
;     57, 49, 41, 33, 25, 17,  9, 1,
;     59, 51, 43, 35, 27, 19, 11, 3,
;     61, 53, 45, 37, 29, 21, 13, 5,
;     63, 55, 47, 39, 31, 23, 15, 7
; };
; 
; code const uint8_t inv_ip_permtab[]  =
; {
;     8, 8,                                          /* 64 bit -> 64 bit */
;     40, 8, 48, 16, 56, 24, 64, 32,
;     39, 7, 47, 15, 55, 23, 63, 31,
;     38, 6, 46, 14, 54, 22, 62, 30,
;     37, 5, 45, 13, 53, 21, 61, 29,
;     36, 4, 44, 12, 52, 20, 60, 28,
;     35, 3, 43, 11, 51, 19, 59, 27,
;     34, 2, 42, 10, 50, 18, 58, 26,
;     33, 1, 41,  9, 49, 17, 57, 25
; };
; 
; // Converts from full 64-bit key to two key halves: left and right.  Only 48
; // bits from the original key are used.
; code const uint8_t pc1_permtab[]  =
; {
;     8,  7,                                         /* 64 bit -> 56 bit*/
;     // Left Half
;     57, 49, 41, 33, 25, 17,  9,
;     1, 58, 50, 42, 34, 26, 18,
;     10,  2, 59, 51, 43, 35, 27,
;     19, 11,  3, 60, 52, 44, 36,
;     // Right Half
;     63, 55, 47, 39, 31, 23, 15,
;     7, 62, 54, 46, 38, 30, 22,
;     14,  6, 61, 53, 45, 37, 29,
;     21, 13,  5, 28, 20, 12,  4
; };
; 
; // Converts the shifted right and left key halves (concatenated together) into
; // the subkey for the round (input into Feistel function).
; code const uint8_t pc2_permtab[]  =
; {
;     7,      6,                                     /* 56 bit -> 48 bit */
;     14, 17, 11, 24,  1,  5,
;     3, 28, 15,  6, 21, 10,
;     23, 19, 12,  4, 26,  8,
;     16,  7, 27, 20, 13,  2,
;     41, 52, 31, 37, 47, 55,
;     30, 40, 51, 45, 33, 48,
;     44, 49, 39, 56, 34, 53,
;     46, 42, 50, 36, 29, 32
; };
; 
; code const uint8_t splitin6bitword_permtab[]  =
; {
;     8,  8,                                         /* 64 bit -> 64 bit */
;     64, 64,  1,  6,  2,  3,  4,  5,
;     64, 64,  7, 12,  8,  9, 10, 11,
;     64, 64, 13, 18, 14, 15, 16, 17,
;     64, 64, 19, 24, 20, 21, 22, 23,
;     64, 64, 25, 30, 26, 27, 28, 29,
;     64, 64, 31, 36, 32, 33, 34, 35,
;     64, 64, 37, 42, 38, 39, 40, 41,
;     64, 64, 43, 48, 44, 45, 46, 47
; };
; 
; code const uint8_t shiftkey_permtab[]  =
; {
;     7,  7,                                         /* 56 bit -> 56 bit */
;     2,  3,  4,  5,  6,  7,  8,  9,
;     10, 11, 12, 13, 14, 15, 16, 17,
;     18, 19, 20, 21, 22, 23, 24, 25,
;     26, 27, 28,  1,
;     30, 31, 32, 33, 34, 35, 36, 37,
;     38, 39, 40, 41, 42, 43, 44, 45,
;     46, 47, 48, 49, 50, 51, 52, 53,
;     54, 55, 56, 29
; };
; 
; code const uint8_t shiftkeyinv_permtab[]  =
; {
;     7,  7,
;     28,  1,  2,  3,  4,  5,  6,  7,
;     8,  9, 10, 11, 12, 13, 14, 15,
;     16, 17, 18, 19, 20, 21, 22, 23,
;     24, 25, 26, 27,
;     56, 29, 30, 31, 32, 33, 34, 35,
;     36, 37, 38, 39, 40, 41, 42, 43,
;     44, 45, 46, 47, 48, 49, 50, 51,
;     52, 53, 54, 55
; };
; 
; #define ROTTABLE      0x7EFC
; #define ROTTABLE_INV  0x3F7E
; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                              Permute data
; *
; * Description: This function is used to obtain the permuted data "out" from input data "in" by table "ptable"
; *
; * Arguments  : ptable   is a pointer to the permutaion table to be used.
; *              Note     ptable is pointer to a different size array, the first of tow element has the size
; *                       of array ,the other element is the permuted data incremented by 1 from the standard
; *
; *              in       is a pointer that holds the data before the permutations.
; *
; *              out      is a pointer that holds the data after the permutation.
; *
; * Returns    : None     the output is inside the out pointer
; *
; * Note(s)    :          we take number from ptable to permute bits of "in" with this
; *                       example
; *                       ptable[3] = 57, so we want to take bit number 57 from data "in"
; *                       but "in" described by 8 bytes, so to get the selective by in in[x/8]
; *                       and get the selective bit by (x%8)
; *********************************************************************************************************
; */
; void permute(const uint8_t *ptable, const uint8_t *in, uint8_t *out) reentrant

	RSEG  ?PR?_?permute?DES
L?0044:
	USING	0
L?0045:
	MOV  	R1,?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#09H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (pc2_permtab)
	MOV  	R1,#LOW (pc2_permtab)
_?permute:
	USING	0
			; SOURCE LINE # 251
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0FBH
	MOV  	?C_IBP,A
; {
;     uint8_t ob;         /* in-bytes and out-bytes */
;     uint8_t byte, _bit;  /* counter for bit and byte */
;     ob = ptable[1];     /* take number of bytes from the 2st element for the table */
			; SOURCE LINE # 255
	ADD  	A,#05H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	DPTR,#01H
	LCALL	?C?CLDOPTR
	MOV  	R0,?C_IBP
	MOV  	@R0,A
;     ptable = &ptable[2];            /* ptable pointed to the 3rd element */
			; SOURCE LINE # 256
	MOV  	A,R1
	ADD  	A,#02H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,?C_IBP
	ADD  	A,#05H
	MOV  	R0,A
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
;     for(byte=0; byte<ob; byte++)
			; SOURCE LINE # 257
	MOV  	R0,?C_IBP
	INC  	R0
	CLR  	A
	MOV  	@R0,A
?C0001:
	MOV  	R1,?C_IBP
	MOV  	R0,?C_IBP
	INC  	R0
	MOV  	A,@R0
	CLR  	C
	SUBB 	A,@R1
	JC   	$ + 5H
	LJMP 	?C0008
;     {
			; SOURCE LINE # 258
;         uint8_t x,t=0;
			; SOURCE LINE # 259
	MOV  	A,?C_IBP
	ADD  	A,#04H
	MOV  	R0,A
	CLR  	A
	MOV  	@R0,A
;         for(_bit=0; _bit<8; ++_bit)
			; SOURCE LINE # 260
	MOV  	R0,?C_IBP
	INC  	R0
	INC  	R0
	MOV  	@R0,A
?C0004:
	MOV  	R0,?C_IBP
	INC  	R0
	INC  	R0
	MOV  	A,@R0
	CLR  	C
	SUBB 	A,#08H
	JC   	$ + 5H
	LJMP 	?C0005
;         {
			; SOURCE LINE # 261
;             x = *ptable++ -1 ;      /* decrement table content by 1 for the standard  */
			; SOURCE LINE # 262
	MOV  	A,?C_IBP
	ADD  	A,#05H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	INC  	R0
	INC  	@R0
	MOV  	A,@R0
	DEC  	R0
	MOV  	AR2,@R0
	JNZ  	?C0036
	INC  	@R0
?C0036:
	DEC  	A
	MOV  	R1,A
	LCALL	?C?CLDPTR
	DEC  	A
	MOV  	R7,A
	MOV  	A,?C_IBP
	ADD  	A,#03H
	MOV  	R0,A
	MOV  	@R0,AR7
;             t <<= 1;                /* select next bit  */
			; SOURCE LINE # 263
	MOV  	A,?C_IBP
	ADD  	A,#04H
	MOV  	R0,A
	PUSH 	AR0
	MOV  	A,@R0
	ADD  	A,ACC
	POP  	AR0
	MOV  	@R0,A
;             if((in[x/8]) & (0x80>>(x%8)) )
			; SOURCE LINE # 264
	MOV  	A,?C_IBP
	ADD  	A,#03H
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	R7,A
	RRC  	A
	RRC  	A
	RRC  	A
	ANL  	A,#01FH
	MOV  	R6,A
	MOV  	A,?C_IBP
	ADD  	A,#08H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	DPL,R6
	MOV  	DPH,#00H
	LCALL	?C?CLDOPTR
	MOV  	R5,A
	MOV  	R4,#00H
	MOV  	A,R7
	ANL  	A,#07H
	MOV  	R7,A
	MOV  	A,#080H
	MOV  	R6,#00H
	MOV  	R0,AR7
	INC  	R0
	SJMP 	?C0038
?C0037:
	XCH  	A,R6
	MOV  	C,ACC.7
	RRC  	A
	XCH  	A,R6
	RRC  	A
?C0038:
	DJNZ 	R0,?C0037
	MOV  	R7,A
	MOV  	A,R6
	ANL  	A,R4
	MOV  	R6,A
	MOV  	A,R7
	ANL  	A,R5
	ORL  	A,R6
	JZ   	?C0006
;             {
			; SOURCE LINE # 265
;                 t|=0x01;
			; SOURCE LINE # 266
	MOV  	A,?C_IBP
	ADD  	A,#04H
	MOV  	R0,A
	MOV  	A,#01H
	ORL  	A,@R0
	MOV  	@R0,A
;             }
			; SOURCE LINE # 267
;         }
			; SOURCE LINE # 268
?C0006:
	MOV  	R0,?C_IBP
	INC  	R0
	INC  	R0
	INC  	@R0
	LJMP 	?C0004
?C0005:
;         out[byte]=t;
			; SOURCE LINE # 269
	MOV  	A,?C_IBP
	ADD  	A,#04H
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	R7,A
	MOV  	A,?C_IBP
	ADD  	A,#0BH
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	R0,?C_IBP
	INC  	R0
	MOV  	A,@R0
	MOV  	DPL,A
	MOV  	DPH,#00H
	MOV  	A,R7
	LCALL	?C?CSTOPTR
;     }
			; SOURCE LINE # 270
	MOV  	R0,?C_IBP
	INC  	R0
	INC  	@R0
	LJMP 	?C0001
; }
			; SOURCE LINE # 271
?C0008:
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	?C_IBP,A
	RET  	
; END OF _?permute

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                              shift key
; *
; * Description: This function is used to shift key by permute it from the permtab
; *
; * Arguments  : key is a pointer to the key (54 bit = 7 byte) to be shifted
; *
; * Returns    : None     the output is inside the key pointer
; *********************************************************************************************************
; */
; void shiftkey(uint8_t *key) reentrant

	RSEG  ?PR?_?shiftkey?DES
L?0048:
	USING	0
L?0049:
	MOV  	R3,#00H
	MOV  	A,?C_IBP
	ADD  	A,#06H
	MOV  	R1,A
	MOV  	R2,#00H
_?shiftkey:
	USING	0
			; SOURCE LINE # 285
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0F9H
	MOV  	?C_IBP,A
; {
;     uint8_t k[7];
;     memcpy(k, key, 7);                              /* copy the content of array "key" in array "k"  */
			; SOURCE LINE # 288
	ADD  	A,#07H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	R0,?C_IBP
	MOV  	R4,#00H
	MOV  	R5,#00H
	MOV  	R6,#00H
	MOV  	R7,#07H
	LCALL	?C?COPY
;     permute((uint8_t*)shiftkey_permtab, k, key);    /* Shift bytes circularly. */
			; SOURCE LINE # 289
	MOV  	A,?C_IBP
	ADD  	A,#07H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#03H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (shiftkey_permtab)
	MOV  	R1,#LOW (shiftkey_permtab)
	LCALL	_?permute
; }
			; SOURCE LINE # 290
	MOV  	A,?C_IBP
	ADD  	A,#0AH
	MOV  	?C_IBP,A
	RET  	
; END OF _?shiftkey

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                              shift key inverting
; *
; * Description: This function is used to shift key back by permute it from the permtab
; *
; * Arguments  : key is a pointer to the key (54 bit = 7 byte) to be shifted
; *
; * Returns    : None     the output is inside the key pointer
; *********************************************************************************************************
; */
; void shiftkey_inv(uint8_t *key)	reentrant

	RSEG  ?PR?_?shiftkey_inv?DES
L?0046:
	USING	0
	LCALL	?C?LSTIDATA
L?0047:
	MOV  	R3,#00H
	MOV  	A,?C_IBP
	ADD  	A,#06H
	MOV  	R1,A
	MOV  	R2,#00H
_?shiftkey_inv:
	USING	0
			; SOURCE LINE # 304
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0F9H
	MOV  	?C_IBP,A
; {
;     uint8_t k[7];
;     memcpy(k, key, 7);
			; SOURCE LINE # 307
	ADD  	A,#07H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	R0,?C_IBP
	MOV  	R4,#00H
	MOV  	R5,#00H
	MOV  	R6,#00H
	MOV  	R7,#07H
	LCALL	?C?COPY
;     permute((uint8_t*)shiftkeyinv_permtab, k, key);
			; SOURCE LINE # 308
	MOV  	A,?C_IBP
	ADD  	A,#07H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#03H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (shiftkeyinv_permtab)
	MOV  	R1,#LOW (shiftkeyinv_permtab)
	LCALL	_?permute
; }
			; SOURCE LINE # 309
	MOV  	A,?C_IBP
	ADD  	A,#0AH
	MOV  	?C_IBP,A
	RET  	
; END OF _?shiftkey_inv

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                              split in 6 bit words
; *
; * Description: This function is used to split every 6bit in a byte to use it with S-Box, so this function
; *              make data from char data[6]-48bit  to data[8]-64bit
; *
; * Arguments  : a        is a pointer to uint64_t that contain content of data[6byte].
; *
; * Returns    : uint64_t this function return a spliced data[8byte]
; *********************************************************************************************************
; */
; void splitin6bitwords(unsigned char a[]) reentrant

	RSEG  ?PR?_?splitin6bitwords?DES
_?splitin6bitwords:
	USING	0
			; SOURCE LINE # 324
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0F8H
	MOV  	?C_IBP,A
; {
;     uint8_t ret[8];
;     memcpy(ret, a, 8);
			; SOURCE LINE # 327
	ADD  	A,#08H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	R0,?C_IBP
	MOV  	R4,#00H
	MOV  	R5,#00H
	MOV  	R6,#00H
	MOV  	R7,#08H
	LCALL	?C?COPY
;     permute((uint8_t*)splitin6bitword_permtab, ret, a);
			; SOURCE LINE # 328
	MOV  	A,?C_IBP
	ADD  	A,#08H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#03H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (splitin6bitword_permtab)
	MOV  	R1,#LOW (splitin6bitword_permtab)
	LCALL	_?permute
; }
			; SOURCE LINE # 329
	MOV  	A,?C_IBP
	ADD  	A,#0BH
	MOV  	?C_IBP,A
	RET  	
; END OF _?splitin6bitwords

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                              substitute
; *
; * Description: This function is used to substitute 6 bits to 4 bits by s-box where 1st and 6th bits
; *              represent row and 2nd,3rd,4th,5th bits represent the columns
; *
; * Arguments  : a        is a pointer to array of char[64] that contain the data want to be substituted
; *                       ,array position.
; *
; *              sbp      is a pointer to array of char[256] S-Box that contain the table of data for
; *                       substitution.
; *
; * Returns    : uint32_t this function return the substituted byte
; *********************************************************************************************************
; */
; uint8_t substitute(uint8_t a, uint8_t * sbp) reentrant

	RSEG  ?PR?_?substitute?DES
_?substitute:
	USING	0
			; SOURCE LINE # 348
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR7
	DEC  	?C_IBP
; {
;     uint8_t x;
;     x = sbp[a>>1];                  /* get the substituted data from S-Box */
			; SOURCE LINE # 351
	MOV  	R0,?C_IBP
	INC  	R0
	MOV  	A,@R0
	MOV  	R7,A
	CLR  	C
	RRC  	A
	MOV  	R6,A
	MOV  	R0,?C_IBP
	INC  	R0
	INC  	R0
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	DPL,R6
	MOV  	DPH,#00H
	LCALL	?C?CLDOPTR
	MOV  	R0,?C_IBP
	MOV  	@R0,A
;     x = (a&1)?x&0x0F:x>>4;          /* depend on 1st bit, we select LSB or MSB */
			; SOURCE LINE # 352
	MOV  	A,R7
	MOV  	R0,?C_IBP
	JNB  	ACC.0,?C0012
	MOV  	A,@R0
	SJMP 	?C0043
?C0012:
	MOV  	A,@R0
	SWAP 	A
?C0043:
	ANL  	A,#0FH
	MOV  	R7,A
?C0013:
	MOV  	R0,?C_IBP
	MOV  	A,R7
	MOV  	@R0,A
;     return x;
			; SOURCE LINE # 353
; }
			; SOURCE LINE # 354
?C0014:
	MOV  	A,?C_IBP
	ADD  	A,#05H
	MOV  	?C_IBP,A
	RET  	
; END OF _?substitute

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                   DES Feistel"Primary function of DES"
; *
; * Description: This function is used to apply the Feistel function on right block with key and return
; *              the result.
; *              note:    Used in encryption and decryption process.
; *
; * Arguments  : r        is a pointer to array of char[4] that contain the data right block.
; *
; *              kr       is a pointer to array of char[4] that contain the data key.
; *
; * Returns    : uint32_t this function return the result of DES Feistel function [32bit]
; *********************************************************************************************************
; */
; uint32_t des_f(uint32_t r, uint8_t* kr)	reentrant

	RSEG  ?PR?_?des_f?DES
_?des_f:
	USING	0
			; SOURCE LINE # 372
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0FCH
	MOV  	?C_IBP,A
	MOV  	R0,A
	LCALL	?C?LSTIDATA
	MOV  	A,?C_IBP
	ADD  	A,#0EBH
	MOV  	?C_IBP,A
; {
;     uint8_t i;
;     uint32_t t=0,ret;
			; SOURCE LINE # 375
	MOV  	R0,A
	INC  	R0
	LCALL	?C?LSTKIDATA
	DB   	00H
	DB   	00H
	DB   	00H
	DB   	00H
;     uint64_t _data;
;     uint8_t *sbp; /* sboxpointer */
; 
;     permute((uint8_t*)e_permtab, (uint8_t*)&r, (uint8_t*)&_data);/* Permute EP "Expansion Permutation" table with
			; SOURCE LINE # 379
	MOV  	A,?C_IBP
	ADD  	A,#09H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#018H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (e_permtab)
	MOV  	R1,#LOW (e_permtab)
	LCALL	_?permute
;                                     input data [right block] "r" and return permuted data in "data[48bit]" */
;     for(i=0; i<7; ++i)
			; SOURCE LINE # 381
	MOV  	R0,?C_IBP
	CLR  	A
	MOV  	@R0,A
?C0015:
	MOV  	R0,?C_IBP
	MOV  	A,@R0
	CLR  	C
	SUBB 	A,#07H
	JNC  	?C0016
;         ((uint8_t*)&_data)[i] ^= kr[i];      /* XORing data [right block] with key [48bit]*/
			; SOURCE LINE # 382
	MOV  	A,@R0
	MOV  	R7,A
	MOV  	R5,A
	MOV  	R3,#00H
	MOV  	A,?C_IBP
	ADD  	A,#09H
	ADD  	A,R5
	MOV  	R1,A
	CLR  	A
	RLC  	A
	MOV  	R2,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	LCALL	?C?CLDPTR
	MOV  	R6,A
	MOV  	A,?C_IBP
	ADD  	A,#019H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	MOV  	DPL,R7
	MOV  	DPH,#00H
	LCALL	?C?CLDOPTR
	XRL  	A,R6
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?CSTPTR
	MOV  	R0,?C_IBP
	INC  	@R0
	SJMP 	?C0015
?C0016:
; 
;     /* Sbox substitution */
;     splitin6bitwords((uint8_t*)&_data);          /* data before 6-byte --> now 8-byte  */
			; SOURCE LINE # 385
	MOV  	R3,#00H
	MOV  	A,?C_IBP
	ADD  	A,#09H
	MOV  	R1,A
	MOV  	R2,#00H
	LCALL	_?splitin6bitwords
;     sbp=(uint8_t*)sbox;
			; SOURCE LINE # 386
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	MOV  	@R0,#0FFH
	INC  	R0
	MOV  	@R0,#HIGH (sbox)
	INC  	R0
	MOV  	@R0,#LOW (sbox)
;     for(i=0; i<8; ++i)
			; SOURCE LINE # 387
	MOV  	R0,?C_IBP
	CLR  	A
	MOV  	@R0,A
?C0018:
	MOV  	R0,?C_IBP
	MOV  	A,@R0
	CLR  	C
	SUBB 	A,#08H
	JNC  	?C0019
;     {
			; SOURCE LINE # 388
;         uint8_t x;
;         x = substitute(((uint8_t*)&_data)[i], sbp);
			; SOURCE LINE # 390
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	R0,?C_IBP
	MOV  	A,@R0
	MOV  	R7,A
	MOV  	R3,#00H
	MOV  	A,?C_IBP
	ADD  	A,#09H
	ADD  	A,R7
	MOV  	R1,A
	CLR  	A
	RLC  	A
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	_?substitute
	MOV  	A,?C_IBP
	ADD  	A,#014H
	MOV  	R0,A
	MOV  	@R0,AR7
;         t <<= 4;
			; SOURCE LINE # 391
	MOV  	R0,?C_IBP
	INC  	R0
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	R0,#04H
	LCALL	?C?LSHL
	POP  	AR0
	LCALL	?C?LSTIDATA
;         t |= x;
			; SOURCE LINE # 392
	MOV  	R0,?C_IBP
	INC  	R0
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	PUSH 	AR7
	MOV  	A,?C_IBP
	ADD  	A,#014H
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	R3,A
	POP  	AR7
	MOV  	A,R7
	ORL  	A,R3
	MOV  	R7,A
	MOV  	A,R4
	POP  	AR0
	LCALL	?C?LSTIDATA
;         sbp += 32;
			; SOURCE LINE # 393
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	INC  	R0
	INC  	R0
	MOV  	A,#020H
	ADD  	A,@R0
	MOV  	@R0,A
	DEC  	R0
	CLR  	A
	ADDC 	A,@R0
	MOV  	@R0,A
;     }
			; SOURCE LINE # 394
	MOV  	R0,?C_IBP
	INC  	@R0
	SJMP 	?C0018
?C0019:
; 
;     permute((uint8_t*)p_permtab,(uint8_t*)&t, (uint8_t*)&ret);
			; SOURCE LINE # 396
	MOV  	A,?C_IBP
	ADD  	A,#05H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#04H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (p_permtab)
	MOV  	R1,#LOW (p_permtab)
	LCALL	_?permute
; 
;     return ret;
			; SOURCE LINE # 398
	MOV  	A,?C_IBP
	ADD  	A,#05H
	MOV  	R0,A
	LCALL	?C?LLDIDATA
; }
			; SOURCE LINE # 399
?C0021:
	MOV  	A,?C_IBP
	ADD  	A,#01CH
	MOV  	?C_IBP,A
	RET  	
; END OF _?des_f

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                      Encryption function
; *
; * Description: 		  This function encrypts a block of 64 bits (8 bytes) with the DES algorithm.
; *                     Key expansion is done automatically. The key is 64 bits long, but note that
; *                     only 56 bits are used (the LSB of each byte is dropped). The input and output
; *                     blocks may overlap.
; *
; * Arguments  : out    pointer to the block (64 bit = 8 byte) where the ciphertext is written to
; *
; *              in     pointer to the block (64 bit = 8 byte) where the plaintext is read from
; *
; *              key    pointer to the key (64 bit = 8 byte)
; *
; * Returns    : None
; *********************************************************************************************************
; */
; void encrypt(void* out, const void* in, const void* key) reentrant

	RSEG  ?PR?_?encrypt?DES
_?encrypt:
	USING	0
			; SOURCE LINE # 420
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0EAH
	MOV  	?C_IBP,A
; {
; #define R (_data.v32[1])
; #define L (_data.v32[0])
;     uint8_t kr[6],k[7];
;     uint8_t i;
;     union
;     {
;         uint8_t v8[8];
;         uint32_t v32[2];
;     } _data;
; 
;     permute((uint8_t*)ip_permtab, (uint8_t*)in, _data.v8);   /* Permute IP "Initial Permutation" table with
			; SOURCE LINE # 432
	ADD  	A,#0EH
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#01CH
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (ip_permtab)
	MOV  	R1,#LOW (ip_permtab)
	LCALL	_?permute
;                                                             input data and return permuted data in "v8" */
;     permute((uint8_t*)pc1_permtab, (const uint8_t*)key, k); /* Permute PC1 "Permuted_Choice1" table with
			; SOURCE LINE # 434
	MOV  	A,?C_IBP
	ADD  	A,#06H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#01FH
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (pc1_permtab)
	MOV  	R1,#LOW (pc1_permtab)
	LCALL	_?permute
;                                                             input key and return permuted data in "k" */
;     for(i=0; i<8; ++i)
			; SOURCE LINE # 436
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	CLR  	A
	MOV  	@R0,A
?C0022:
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	MOV  	A,@R0
	CLR  	C
	SUBB 	A,#08H
	JC   	$ + 5H
	LJMP 	?C0023
;     {
			; SOURCE LINE # 437
;         shiftkey(k);
			; SOURCE LINE # 438
	LCALL	L?0048
; 
;         if(i==1||i==2||i==3||i==5||i==6||i==7)          /* filtered from round "zero" and round "four" 1,2,3,5,6,7 */
			; SOURCE LINE # 440
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	R7,A
	XRL  	A,#01H
	JZ   	?C0026
	MOV  	A,R7
	XRL  	A,#02H
	JZ   	?C0026
	MOV  	A,R7
	XRL  	A,#03H
	JZ   	?C0026
	MOV  	A,R7
	XRL  	A,#05H
	JZ   	?C0026
	MOV  	A,R7
	XRL  	A,#06H
	JZ   	?C0026
	MOV  	A,R7
	CJNE 	A,#07H,?C0025
?C0026:
;             shiftkey(k);
			; SOURCE LINE # 441
	LCALL	L?0048
?C0025:
;         permute((uint8_t*)pc2_permtab, k, kr);
			; SOURCE LINE # 442
	LCALL	L?0044
;         L ^= des_f(R, kr);
			; SOURCE LINE # 443
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	MOV  	R3,#00H
	MOV  	R1,?C_IBP
	MOV  	R2,#00H
	MOV  	A,?C_IBP
	ADD  	A,#012H
	MOV  	R0,A
	LCALL	?C?LLDIDATA
	LCALL	_?des_f
	MOV  	R0,AR4
	MOV  	R1,AR5
	MOV  	R2,AR6
	MOV  	R3,AR7
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;         shiftkey(k);
			; SOURCE LINE # 444
	LCALL	L?0049
;         if(i==1||i==2||i==3||i==4||i==5||i==6)     /* filtered from round "zero" and round "seven" 1,2,3,4,5,6 */
			; SOURCE LINE # 445
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	MOV  	A,@R0
	MOV  	R7,A
	XRL  	A,#01H
	JZ   	?C0028
	MOV  	A,R7
	XRL  	A,#02H
	JZ   	?C0028
	MOV  	A,R7
	XRL  	A,#03H
	JZ   	?C0028
	MOV  	A,R7
	XRL  	A,#04H
	JZ   	?C0028
	MOV  	A,R7
	XRL  	A,#05H
	JZ   	?C0028
	MOV  	A,R7
	CJNE 	A,#06H,?C0027
?C0028:
;             shiftkey(k);
			; SOURCE LINE # 446
	LCALL	L?0049
?C0027:
; 
;         permute((uint8_t*)pc2_permtab, k, kr);
			; SOURCE LINE # 448
	LCALL	L?0044
;         R ^= des_f(L, kr);
			; SOURCE LINE # 449
	MOV  	A,?C_IBP
	ADD  	A,#012H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	MOV  	R3,#00H
	MOV  	R1,?C_IBP
	MOV  	R2,#00H
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	R0,A
	LCALL	?C?LLDIDATA
	LCALL	_?des_f
	MOV  	R0,AR4
	MOV  	R1,AR5
	MOV  	R2,AR6
	MOV  	R3,AR7
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     }
			; SOURCE LINE # 450
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	INC  	@R0
	LJMP 	?C0022
?C0023:
;     /* L <-> R*/
;     R ^= L;
			; SOURCE LINE # 452
	MOV  	A,?C_IBP
	ADD  	A,#012H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     L ^= R;
			; SOURCE LINE # 453
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#012H
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     R ^= L;
			; SOURCE LINE # 454
	MOV  	A,?C_IBP
	ADD  	A,#012H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#0EH
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
; 
;     // Switch back left and right block
;     permute((uint8_t*)inv_ip_permtab, _data.v8, (uint8_t*)out);
			; SOURCE LINE # 457
	MOV  	A,?C_IBP
	ADD  	A,#016H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#011H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (inv_ip_permtab)
	MOV  	R1,#LOW (inv_ip_permtab)
	LCALL	_?permute
; }
			; SOURCE LINE # 458
	MOV  	A,?C_IBP
	ADD  	A,#01FH
	MOV  	?C_IBP,A
	RET  	
; END OF _?encrypt

; 
; /*$PAGE*/
; /*
; *********************************************************************************************************
; *                                      Decryption function
; *
; * Description: This function decrypts a block of 64 bits (8 bytes) with the DES algorithm.
; *              Key expansion is done automatically. The key is 64 bits long, but note that
; *              only 56 bits are used (the LSB of each byte is dropped). The input and output
; *              blocks may overlap.
; *
; * Arguments  : out    pointer to the block (64 bit = 8 byte) where the plaintext is written to
; *
; *              in     pointer to the block (64 bit = 8 byte) where the ciphertext is read from
; *
; *              key    pointer to the key (64 bit = 8 byte)
; *
; * Returns    : None
; *********************************************************************************************************
; */
; void decrypt(void* out, const void* in, const uint8_t* key) reentrant

	RSEG  ?PR?_?decrypt?DES
_?decrypt:
	USING	0
			; SOURCE LINE # 479
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#0EAH
	MOV  	?C_IBP,A
; {
;     uint8_t kr[6],k[7];
;     union
;     {
;         uint8_t v8[8];
;         uint32_t v32[2];
;     } _data;
;     int8_t i;
;     permute((uint8_t*)ip_permtab, (uint8_t*)in, _data.v8);/* Permute IP "Initial Permutation" table with
			; SOURCE LINE # 488
	ADD  	A,#0DH
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#01CH
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (ip_permtab)
	MOV  	R1,#LOW (ip_permtab)
	LCALL	_?permute
;                                                             input data and return permuted data in "v8" */
;     permute((uint8_t*)pc1_permtab, (const uint8_t*)key, k);/* Permute PC1 "Permuted_Choice1" table with
			; SOURCE LINE # 490
	MOV  	A,?C_IBP
	ADD  	A,#06H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	A,?C_IBP
	ADD  	A,#01FH
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (pc1_permtab)
	MOV  	R1,#LOW (pc1_permtab)
	LCALL	_?permute
;                                                             input key and return permuted data in "k" */
;     for(i=7; i>=0; --i)
			; SOURCE LINE # 492
	MOV  	A,?C_IBP
	ADD  	A,#015H
	MOV  	R0,A
	MOV  	@R0,#07H
?C0030:
	MOV  	A,?C_IBP
	ADD  	A,#015H
	MOV  	R1,A
	CLR  	C
	MOV  	A,@R1
	XRL  	A,#080H
	SUBB 	A,#080H
	JNC  	$ + 5H
	LJMP 	?C0031
;     {
			; SOURCE LINE # 493
;         permute((uint8_t*)pc2_permtab, k, kr);
			; SOURCE LINE # 494
	LCALL	L?0045
;         L ^= des_f(R, kr);
			; SOURCE LINE # 495
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	MOV  	R3,#00H
	MOV  	R1,?C_IBP
	MOV  	R2,#00H
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	LCALL	?C?LLDIDATA
	LCALL	_?des_f
	MOV  	R0,AR4
	MOV  	R1,AR5
	MOV  	R2,AR6
	MOV  	R3,AR7
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
;         shiftkey_inv(k);
			; SOURCE LINE # 496
	LCALL	L?0046
;         if(ROTTABLE&((1<<((i<<1)+1))) )     /* filtered from round "zero" and round "seven" 1,2,3,4,5,6 */
			; SOURCE LINE # 497
	MOV  	A,?C_IBP
	ADD  	A,#015H
	MOV  	R0,A
	MOV  	A,@R0
	ADD  	A,ACC
	INC  	A
	MOV  	R7,A
	MOV  	A,#01H
	MOV  	R6,#00H
	MOV  	R0,AR7
	INC  	R0
	SJMP 	?C0040
?C0039:
	CLR  	C
	RLC  	A
	XCH  	A,R6
	RLC  	A
	XCH  	A,R6
?C0040:
	DJNZ 	R0,?C0039
	MOV  	R7,A
	MOV  	A,R6
	ANL  	A,#07EH
	MOV  	R6,A
	MOV  	A,R7
	ANL  	A,#0FCH
	ORL  	A,R6
	JZ   	?C0033
;             shiftkey_inv(k);
			; SOURCE LINE # 498
	LCALL	L?0047
?C0033:
; 
;         permute((uint8_t*)pc2_permtab, k, kr);
			; SOURCE LINE # 500
	LCALL	L?0045
;         R ^= des_f(L, kr);
			; SOURCE LINE # 501
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	MOV  	R3,#00H
	MOV  	R1,?C_IBP
	MOV  	R2,#00H
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	LCALL	?C?LLDIDATA
	LCALL	_?des_f
	MOV  	R0,AR4
	MOV  	R1,AR5
	MOV  	R2,AR6
	MOV  	R3,AR7
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
;         shiftkey_inv(k);
			; SOURCE LINE # 502
	LCALL	L?0046
;         if(ROTTABLE&((1<<((i<<1)+0))) )        /* filtered from round "zero" and round "four" 1,2,3,5,6,7 */
			; SOURCE LINE # 503
	MOV  	A,?C_IBP
	ADD  	A,#015H
	MOV  	R0,A
	MOV  	A,@R0
	ADD  	A,ACC
	MOV  	R7,A
	MOV  	A,#01H
	MOV  	R6,#00H
	MOV  	R0,AR7
	INC  	R0
	SJMP 	?C0042
?C0041:
	CLR  	C
	RLC  	A
	XCH  	A,R6
	RLC  	A
	XCH  	A,R6
?C0042:
	DJNZ 	R0,?C0041
	MOV  	R7,A
	MOV  	A,R6
	ANL  	A,#07EH
	MOV  	R6,A
	MOV  	A,R7
	ANL  	A,#0FCH
	ORL  	A,R6
	JZ   	?C0032
;             shiftkey_inv(k);
			; SOURCE LINE # 504
	LCALL	L?0047
;     }
			; SOURCE LINE # 505
?C0032:
	MOV  	A,?C_IBP
	ADD  	A,#015H
	MOV  	R0,A
	DEC  	@R0
	LJMP 	?C0030
?C0031:
;     /* L <-> R*/
;     R ^= L;
			; SOURCE LINE # 507
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     L ^= R;
			; SOURCE LINE # 508
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     R ^= L;
			; SOURCE LINE # 509
	MOV  	A,?C_IBP
	ADD  	A,#011H
	MOV  	R0,A
	PUSH 	AR0
	LCALL	?C?LLDIDATA
	MOV  	A,?C_IBP
	ADD  	A,#0DH
	MOV  	R0,A
	LCALL	?C?LLDIDATA0
	MOV  	A,R7
	XRL  	A,R3
	MOV  	R7,A
	MOV  	A,R6
	XRL  	A,R2
	MOV  	R6,A
	MOV  	A,R5
	XRL  	A,R1
	MOV  	R5,A
	MOV  	A,R4
	XRL  	A,R0
	MOV  	R4,A
	POP  	AR0
	LCALL	?C?LSTIDATA
;     permute((uint8_t*)inv_ip_permtab, _data.v8, (uint8_t*)out);
			; SOURCE LINE # 510
	MOV  	A,?C_IBP
	ADD  	A,#016H
	MOV  	R0,A
	MOV  	AR3,@R0
	INC  	R0
	MOV  	A,@R0
	MOV  	R2,A
	INC  	R0
	MOV  	A,@R0
	MOV  	R1,A
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,AR3
	INC  	R0
	MOV  	@R0,AR2
	INC  	R0
	MOV  	@R0,AR1
	MOV  	A,?C_IBP
	ADD  	A,#010H
	DEC  	?C_IBP
	DEC  	?C_IBP
	DEC  	?C_IBP
	MOV  	R0,?C_IBP
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,#00H
	INC  	R0
	MOV  	@R0,A
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (inv_ip_permtab)
	MOV  	R1,#LOW (inv_ip_permtab)
	LCALL	_?permute
; }
			; SOURCE LINE # 511
	MOV  	A,?C_IBP
	ADD  	A,#01FH
	MOV  	?C_IBP,A
	RET  	
; END OF _?decrypt

	END
